<!DOCTYPE html>
<html lang="en">
<head>
    <title>Algorithems</title>
    <!-- <link rel="icon" href="aggothem.jpeg"> -->
</head>
<body bgcolor="#FFF0F5">
    <h1>1. Learn Algorithms</h1>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        Once you have cleared the concepts of Data Structures, now its time to start your journey through the Algorithms. Based on the type of nature and usage, the Algorithms are grouped together into several categories, as shown below:</p>
    <h3>1. Searching Algorithm</h3>
    <p>Searching algorithms are used to find a specific element in an array, string, linked list, or some other data structure. </p>
    <p>The most common searching algorithms are:</p>
    <ul>
        <li><p><u><b>Linear Search -</b></u> In this searching algorithm, we check for the element iteratively from one end to the other.</p></li>
        <li><p><b><u>Binary Search -</u></b>In this type of searching algorithm, we break the data structure into two equal parts and try to decide in which half we need to find for the element. </p></li>
        <li><p><b><u>Ternary Search -</u></b>In this case, the array is divided into three parts, and based on the values at partitioning positions we decide the segment where we need to find the required element.</p></li>
    </ul>
    <h3>2. Sorting Algorithm</h3>
    <p>Sorting Algorithm is used to rearrange a given array or list elements according to a comparison operator on the elements. The comparison operator is used to decide the new order of element in the respective data structure.</p>
    <center><img src="Sorting-Algorithms.png" alt=""></center>
    <p>There are a lot of different types of sorting algorithms. Some widely used algorithms are:</p>
    <ul>
        <li>Bubble Sort</li>
        <li>Selection Sort</li>
        <li>Insertion Sort</li>
        <li>Quick Sort</li>
        <li>Merge Sort</li>
    </ul>
    <h3>3. Divide and Conquer Algorithm</h3>
    <p>Divide and Conquer is an algorithmic paradigm. A typical Divide and Conquer algorithm solves a problem using following three steps.</p>
    <ol type="1">
        <li><p><b>Divide:</b> Break the given problem into subproblems of same type.</p></li>
        <li><p><b>Conquer:</b> Recursively solve these subproblems.</p></li>
        <li><p><b>Combine:</b> Appropriately combine the answers.</p></li>
    </ol>
    <h3>4. Greedy Algorithms</h3>
    <p>As the name suggests, this algorithm builds up the solution one piece at a time and chooses the next piece which gives the most obvious and immediate benefit i.e., which is the most optimal choice at that moment. So the problems where choosing locally optimal also leads to the global solutions are best fit for Greedy.</p>
    <center><img src="recursion.png" alt=""></center>
    <h3>5. Recursion</h3>
    <p>Recursion is one of the most important algorithms which uses the concept of code reusability and repeated usage of the same piece of code. </p>
    <center><img src="re.jpeg" alt="" height="450px" width="800px"></center>
    <h3>6. Backtracking Algorithm</h3>
    <p><b>Backtracking</b> is an algorithmic technique for solving problems recursively by trying to build a solution incrementally, one piece at a time, removing those solutions that fail to satisfy the constraints of the problem at any point of time </p>
    <h3>7. Dynamic Programming</h3>
    <p>The main concept of the <b>Dynamic Programming</b> algorithm is to use the previously calculated result to avoid repeated calculations of the same subtask which helps in reducing the time complexity. </p>
    <center><img src="Dynamic-Programming-1-1024x512.png" alt=""></center>
    <h3>8. Pattern Searching</h3>
    <p>The Pattern Searching algorithms are sometimes also referred to as String Searching Algorithms and are considered as a part of the String algorithms. These algorithms are useful in the case of searching a string within another string.</p>
    <center><img src="image.png" alt=""></center>
    <h3>9. Mathematical Algorithms</h3>
    <p>These algorithms are designed to solve Mathematical and Number Theory problems. They requires in-depth knowledge of different mathematical concepts like</p>
    <ul>
        <li>GCD and LCM</li>
        <li>Prime Factorization and Divisors</li>
        <li>Fibonacci Numbers</li>
        <li>Catalan Numbers</li>
        <li>Modular Arithmetic</li>
        <li>Euler Totient Function</li>
        <li>nCr Computations</li>
        <li>Set Theory</li>
        <li>Factorial</li>
        <li>Prime numbers and Primality Tests</li>
        <li>Sieve Algorithms, etc.</li>
    </ul>
    <h3>10. Geometric Algorithms</h3>
    <p>These algorithms are designed to solve Geometric Problems. They requires in-depth knowledge of different mathematical concepts like:</p>
    <ul>
        <li>Lines</li>
        <li>Triangle</li>
        <li>Rectangle</li>
        <li>Square</li>
        <li>Circle</li>
        <li>3D Objects</li>
        <li>Quadilateral</li>
        <li>Polygon & Convex Hull</li>
    </ul>
    <h3>11. Bitwise Algorithms</h3>
    <p>The <b>Bitwise Algorithms</b> is used to perform operations at the bit-level or to manipulate bits in different ways. The bitwise operations are found to be much faster and are sometimes used to improve the efficiency of a program.</p>
    <p><b>For example:</b> To check if a number is even or odd. This can be easily done by using Bitwise-AND(&) operator. If the last bit of the operator is set than it is ODD otherwise it is EVEN. Therefore, if num & 1 not equals to zero than num is ODD otherwise it is EVEN.</p>
    <h3>12. Randomized Algorithms</h3>
    <p>An algorithm that uses random numbers to decide what to do next anywhere in its logic is called Randomized Algorithm. For example, in Randomized Quick Sort, we use a random number to pick the next pivot (or we randomly shuffle the array). Typically, this randomness is used to reduce time complexity or space complexity in other standard algorithms.</p>
    <h3>13. Branch and Bound Algorithm</h3>
    <p><b>Branch and bound</b> is an algorithm design paradigm which is generally used for solving combinatorial optimization problems. These problems are typically exponential in terms of time complexity and may require exploring all possible permutations in worst case. The Branch and Bound Algorithm technique solves these problems relatively quickly.</p>
</body>
</html>